//formatting rules:
//{ on same line
//multicomment lines go above line
//single line comments on same line and tabbed 
//for function:what it does, name inputs and outputs define

#include "I2Cdev.h"		// provides simple and intuitive interfaces to I2C devices
#include "MPU6050.h"		// IMU library
#include "Wire.h"		// allows you to communicate with I2C / TWI devices
#include <SFE_BMP180.h>		// pressure/temp sensor library
#include <Servo.h>		// servo library
#include <SPI.h>		// Serial Peripheral Interface(SPI) used for communicating with one or more peripheral devices quickly over short distances
#include <SD.h>			// microSD card library

#define R 1716  		// (ft*lb)/(slug*degree_R) 
#define g 32.174		// ft/s^2

int pos=0;			// postition of the servo (degrees?)

//These are not all on the same line to comment them
double Xprev = 0;		// previous x acceleration
double PnextAx = 0;		//
double PnextALT = 0; 		//
double alt_prev = 0; 		//
double alt_refine;		// 
double Ax;			//
double VelocityNew;		//
double Velocity;		//
double OldVelocity = 0;		//
double PositionNew;		//
double Position = 0;		//
double ALTREFINE;		//
double slopeVelocity = 0;	// velocity from BMP, derived from position
double baseline; 		// baseline pressure

unsigned long T=0,		//
unsigned long TimeOfLaunch=0;	//
unsigned long TimeSinceLaunch=0;//
unsigned long time=0;   	//
unsigned long OldTime=0;	//


//Objects
SFE_BMP180 bmp;
MPU6050 mpu;
Servo servo;
File dataFile;			// the datafile variable to save stuff to microSD



//MPU 6050 Accelerations
int16_t accX, accY, accZ; 	// unfiltered accelerations, assigns 16 bit signed integers, used for balence of precision and speed

//BMP180 Altitude
double altitude;		// yup

void setup() {
  mpuSetup();			// all aptly named
  bmpSetup();
  serialSetup();
  servoSetup();
  //SDcardSetup(); 		//set up sd card to read RC data
  SDcardWriteSetup(); 		//setup sd card to write data to
  
}

void loop() { // run code ( main code)
// and so we begin

	// Launch detection have the getAcc built in 
	if(launchDetect==0){// this is probably redundant in the function, we could take the function one  //JK 
		(TimeOfLaunch)=LaunchDetection(&launchDetect);
	}
	//is this necessary at all? what is the point of launch detection? this could be deleted when we write the function to recognize 
	//when the acceleration turns negative, that way we don't have to depend on time to make sure that the brakes don't actuate when the 
	//motor is on, big no-no from NASA


T=millis(); // this is needed to distinguish from time in brakingloop
TimeSinceLaunch=T-TimeOfLaunch;  




/*(tanner)
PoweredTime=2300; 	//NO
write a function to recognize when the engine turns off aka when the acceleration turns negative
*/





BrakingLoop(TimeSinceLaunch,PoweredTime,&BT);		//in the process of being changed

time=millis();  					// current time for measurements
getAcc(); 						// Updates accX,accY,accZ
getAlt(); 						// Updates altitude

(Ax)=kalman(accX,    Xprev,   &PnextAx); 		// calls the kalman filter to refine acceleration in the X direction
(alt_refine)=kalman(altitude,alt_prev, &PnextALT); 	// refines altitude 


slopeVelocity=SlopeVelocity(OldTime,time,alt_prev,alt_refine); 		// deriving velocity from position from BMP
VelocityNew=integrate(OldTime,time,Xprev,Ax);				// integrating acceleration from MPU since last measurement to get velocity
OldVelocity=Velocity;							// still need the now old velocity to find position at that time 
Velocity=Velocity+VelocityNew;						// calculates the now new velocity
PositionNew=integrate(OldTime,time,OldVelocity,Velocity);		// integration to find position from MPU
Position=Position+PositionNew;  					// Position is defined as 0 at start 


OldTime=time;		// ms, reassigns time for lower bound at next integration cycle
Xprev=Ax;		// Xprev will be started at 0   
alt_prev=alt_refine;  	// alt_prev will started at 0 in definitions

ALTREFINE=alt_refine;

if (TimeSinceLaunch>PoweredTime) {
	BT=ApogeeCall(ALTREFINE,H1,H2,H3,slopeVelocity,&Brake1,&Brake2,&Brake3); //will be reworked
}
//These two will be rewritten into one 
FreefallDetection(accX,accY,Brake3); 	// Freefall
Abort(launchDetect);			// Abortion

writeData();	// writes all pertinent data

}
//--------------------------------------------------------------Beginning of the Functions---------------------------------------------
 
//--------------------------------------------------------------SD Card Functions------------------------------------------------------
void SDcardSetup(){
	pinMode(4, OUTPUT);
  	SD.begin(4);  
}

void SDcardWriteSetup(){
	dataFile = SD.open("Data.txt", FILE_WRITE);
	dataFile.println("Time(ms),Height(ft),F Alt(ft),AccX(ft/s^2),AccY(ft/s^2),AccZ(ft/s^2),F Acc(ft/s^2),SlopeVel(ft/s)");
	dataFile.close();	
}

void writeData(){
 dataFile = SD.open("Data.txt", FILE_WRITE);
 dataFile.print(millis());
 dataFile.print(",");
 dataFile.print(altitude);
 dataFile.print(",");
 dataFile.print(alt_refine);
 dataFile.print(",");
 dataFile.print(accX);
 dataFile.print(",");
 dataFile.print(accY);
 dataFile.print(",");
 dataFile.print(accZ);
 dataFile.print(",");
 dataFile.print(Ax);
 dataFile.print(",");
 dataFile.println(slopeVelocity);
 dataFile.close();
}

void abortWrite(){
dataFile = SD.open("Data.txt", FILE_WRITE);
dataFile.println("ABORT DETECTED");
dataFile.close();
}

void launchDetectWrite(){
dataFile = SD.open("Data.txt", FILE_WRITE);
dataFile.println("LAUNCH DETECTED");
dataFile.close();
}

void freefallWrite(){
dataFile = SD.open("Data.txt", FILE_WRITE);
dataFile.println("FREEFALL DETECTED");
dataFile.close();
}

void openWrite(){
dataFile = SD.open("Data.txt", FILE_WRITE);
dataFile.println("BRAKE OPENED");
dataFile.close();
}

void closeWrite(){
dataFile = SD.open("Data.txt", FILE_WRITE);
dataFile.println("BRAKE CLOSED");
dataFile.close();
}

void btWrite(){
dataFile = SD.open("Data.txt", FILE_WRITE);
dataFile.print("BT:");
dataFile.println(BT);
dataFile.close();
}

//Serial Setup
void serialSetup(){
 Serial.begin(9600);
}

//-----------------------------------------------------------Servo Methods--------------------------------------------------------------                                   
						Adjust this to the current settings?
void servoSetup(){
  servo.attach(9);
  servo.write(0);
}

void closeServo(){
	if (pos>0){
  		do{
			pos -= 10;
			//140degree                      // in steps of 5 degree 
			servo.write(pos);              // tell servo to go to position in variable 'pos' 
			delay(20);    					// waits 15ms for the servo to reach the position 
		}
		while(pos >0);
	}
	
}

void openServo(){
	if (pos<200){
		do{
			pos += 10;
			//140degree                     // in steps of 5 degree 
			servo.write(pos);              	// tell servo to go to position in variable 'pos' 
			delay(20);			// waits 20ms for the servo to reach the position 
			//I get that it's necessary to account for physical time for it to move but why make it wait?
			//if it gets around to this point again before the airbrake is done, it'll just keep moving, I would think at least
		}
		while(pos <=200);
	} 
}
//-------------------------------------------------------------------BMP 180 Methods----------------------------------------------------

void bmpSetup(){
  bmp.begin();
  baseline = getPressure();
}

double getPressure(){
  char status;
  double T,P,p0,a;

  // You must first get a temperature measurement to perform a pressure reading.
  
  // Start a temperature measurement:
  // If request is successful, the number of ms to wait is returned.
  // If request is unsuccessful, 0 is returned.

  status = bmp.startTemperature();
  if (status != 0)
  {
    // Wait for the measurement to complete:

    delay(status);

    // Retrieve the completed temperature measurement:
    // Note that the measurement is stored in the variable T.
    // Use '&T' to provide the address of T to the function.
    // Function returns 1 if successful, 0 if failure.

    status = bmp.getTemperature(T);
    if (status != 0)
    {
      // Start a pressure measurement:
      // The parameter is the oversampling setting, from 0 to 3 (highest res, longest wait).
      // If request is successful, the number of ms to wait is returned.
      // If request is unsuccessful, 0 is returned.

      status = bmp.startPressure(3);
      if (status != 0)
      {
        // Wait for the measurement to complete:
        delay(status);

        // Retrieve the completed pressure measurement:
        // Note that the measurement is stored in the variable P.
        // Use '&P' to provide the address of P.
        // Note also that the function requires the previous temperature measurement (T).
        // (If temperature is stable, you can do one temperature measurement for a number of pressure measurements.)
        // Function returns 1 if successful, 0 if failure.

        status = bmp.getPressure(P,T);
        if (status != 0)
        {
          return(P);
        }
        else Serial.println("error retrieving pressure measurement\n");
      }
      else Serial.println("error starting pressure measurement\n");
    }
    else Serial.println("error retrieving temperature measurement\n");
  }
  else Serial.println("error starting temperature measurement\n");
}

void getAlt(){
double a,P;
  
  // Get a new pressure reading:
  P = getPressure();

  // Show the relative altitude difference between
  // the new reading and the baseline reading:
  a = bmp.altitude(P,baseline);
  
  //convert to ft
  altitude =a*3.28084; 
  }

void resetBmp(){
  baseline = getPressure();
}

//--------------------------------------------------------------------MPU 6050 Methods--------------------------------------------------
void getAcc(){
   mpu.getAcceleration(&accX, &accY, &accZ);
   //what is map?
   accX = map(accX, 0, 4096, 0, 32);
   accY = map(accY, 0, 4096, 0, 32);
   accZ = map(accZ, 0, 4096, 0, 32);
}

void mpuSetup(){
    //????????? 
    #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
        Wire.begin();
    #elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE
        Fastwire::setup(400, true);
    #endif
    mpu.initialize();
    mpu.setFullScaleAccelRange(2);  //0=2g, 1=4g, 2=8g, 3=16g
    mpu.setFullScaleGyroRange(2); //0=250 deg/s, 1=500 deg/s, 2=1000 deg/s, 3=2000 deg/s 
    calibrateMPU();
}

//------------------------------------------------------------IMPORTANT FUNCTIONS-------------------------------------------------------
double kalman(double UnFV,double FR1,double *Pold){

/* function filtering results in real time with Kalman filter */
	int A=1,un=0,H=1,B=0;
	double Prediction,P,y,S,K,FR2;

	double Q,R; 
		Q=0.1;
		R=0.2;      // defined these from the Matlab code
	// inputs are Unfiltered Response, Filtered  response, Prediction value old
	// Q and R are sensor specific values (probably)
	// make sure to predefine P and possibly other values at the beginning of the main code. starts at 1

	//UnFV		// unfiltered value from sensors read in (zn)						-internal logic
	//FR1           // read this variable in from main (AX(i)) defined last iteration			-internal logic
	//Pold    	// output Pold and read in Pold from last iteration					-input,output
	//Q		// sensor specific value, we might default this						-input
	//R		// sensor specific value, we might default this						-input
	//A					
	
	Prediction= A*FR1 +B*un; // State Prediction 		(Predict where we're goning to be)
	P=A*(*Pold)*A +Q;		 // Covariance Prediction 	(Predict how much error)
	y=UnFV-H*Prediction;	 // Innovation  			(Compare reality against prediction)
	S= H*P*H +R;			 // innovation Covariance 	(Compare real error against prediction)
	K=(P*H)/S;				 //Kalman Gain 				(Moderate the prediction)
	FR2=Prediction+K*y;		 //state update 			(New estimate of where we are)
	(*Pold)=(1-K*H)*P;		 //Covariance update 		(New estimate of error)
	
	return FR2;  
}

double ApogeeCall(double ALTREFINE,int H1, int H2, int H3, double V,int *Brake1, int *Brake2,int *Brake3){//taylor
	
	//this will be completely rewritten
	
	double BT;
	int HT;
	//this code has a prediction built in  to it
	
	// we want to make a code that will still deploy air brakes if we accidentally exceed an altitude
	// without deploying the brakes
	
	// ALTREFINE  is the mediated result from the BMP and MPU					-input
	// H1, H2 ,H3 are altitudes that we want to check what's going on           			-input 
	// V, Current velocity										-input
	// BT is the time brakes will be deployed							-output			
	// ALTREFINE=2001;???
	// BrakeN is a counter to ensure only one braking cycle per section.				-internal logic


if ( (*Brake1==0) && (ALTREFINE >= H1)){
	// HT is the target height for the iteration
	HT=3070; // ft
	BT=ApogeePrediction(ALTREFINE,V,HT);
	
	// What if the Prediction is lower than HT?
	*Brake1=1;
	//Serial.println("BRAKE1-----------------");
	brake1Write();
}

	else if ((ALTREFINE>=H2) && (*Brake2==0)){
		HT=3025; // ft
	BT=ApogeePrediction(ALTREFINE,V,HT);
	// include in this function the turn on key
	*Brake2=1;
	brake2Write();
}
	else if ((ALTREFINE>=H3) && (*Brake3==0)){
		HT=3000; // ft
	BT=ApogeePrediction(ALTREFINE,V,HT);

	// include in this function the turn on 
	*Brake3=1;
	brake3Write();
}
	else {
	BT=0;
	}

return BT;
}

double ApogeePrediction( double ALTREFINE, double V, double HT) {
	double NRG1,NRG2,Vout,ACC,FrontArea,D,BT;
	int MassE,G;
	
	//Hn              // Current Height value				-input
	//HT				// Height of Target apogee				-input
	//V				// Velocity in ft/s					-input
	//MassE			// Mass of rocket Empty				-internal logic
	//NRG1			// Current Energy of rocket			-internal logic
	//G 		   	 	// Value of gravity in ft/s^2			-internal logic
	//NRG2			// Desired Energy of rocket			-internal logic
	//Vout			// Velocity we need to be at currently	-internal logic
	//ACC			// Acceleration due to drag and Gravity	-internal logic
	//D				// Drag Force							-internal logic
	//FrontArea		// Frontal area of rocket				-internal logic
	//BT 			// Braking Time ms					-output
	//BT				// Braking time(s)					-output
	
	// internal logic variable declarations
	MassE=50; // True mass is 26.5 some   lb //Change this<----------------------------------------------------------------------------------
	G=32; // ft/s
	
	//drag equation
	FrontArea=.78; //ft^2
	D=.85*((0.0023769*V*V)/2)*FrontArea;
	ACC=D/MassE;
	
	// double check the drag equation here. cause its just kinda arbitrary
	NRG1= MassE*G*ALTREFINE;
	NRG2= MassE*G*HT;
	Vout= sqrt(((NRG2-NRG1)*2)/MassE);         // might need                   DOUBLE CHECK THE MATH HERE
	BT=(V-Vout)/(ACC+32);      // this is for drag     // BT should be in seconds
	BT=BT*1000; // convert to milliseconds
	
	
	if (BT>0){
	openServo(); // this will open the servo for this iteration if necessary this should be the only way to open the brakes
	openWrite();
	}
   return BT;
}

double integrate(unsigned long time1, unsigned long time2, double Val1, double Val2) {

	//function requires two times, and two  data points

	double Time2, Time1;
	Time2=time2/1000;
	Time1=time1/1000;

	//Area				//result of integration  		-output
	//Val1				//input of initial value		-input
	//Val2				//input of secondary inital 	-input
	//deltaT				//change in time				-internal logic
	//deltaA				//change in value				-internal logic
	//time2				//time previous				-input
	//time1				//time current				-input


	double deltaT, deltaA;     // declares Change in time, Change in Acceleration
	double Area; 		   // declares Final Area
	deltaT = Time2-Time1;      // computes deltaT
	deltaA = (Val2+Val1)/2;    // computes deltaA
	Area = deltaT*deltaA; 	   // computes Area
	
	return Area; 
}	

void BrakingLoop(unsigned long TimeSinceLaunch, int PoweredTime, int *BT){     // double check for class definition and output class

// this will need to be rewritten to recognize when motor runs out aka when acceleration turns negative

	//TimeSinceLaunch				// Time since launch detection					-input 
	//PoweredTime 		    		// The time that the motor will burn (ms)		-input (also for internal logic)
	//BT							// The braking time duration that  (ms)			-input/output with pointer		
	//TimeStep					// time since Breaking started					-internal logic
	int TimeStep,TimeStepStart;
	if (TimeSinceLaunch>PoweredTime){
		if (*BT>0){
		btWrite();
		TimeStepStart=millis();
			do{
				TimeStep=millis()-TimeStepStart;
				getAcc();
				getAlt();
				writeData();
					if (TimeStep>=*BT){
					closeServo(); 		// Closing the brakes state   will call on function  this will be the only closing function
					TimeStep=0;  		// Resetting the counter
					*BT=0    ;			// Reset the Braking time to 0 (this is a back up procedure)
					}
			}while(*BT>0);
		}

	}

}

void FreefallDetection(int accX,int accY,int Brake3){//tanner
int freefallDetect;
	if ((accX <= 1 && accX >= -50)&&(Brake3==1)){ 
		freefallDetect=1;
		freefallWrite();
		closeServo();
		do {
			getAcc();
			getAlt();
			delay(200);
			writeData();
		}
		while(freefallDetect==1);
	}
}

unsigned long LaunchDetection(int *launchDetect){
 
 //TimeOfLaunch 			//The time on global clock when launch is detected		-output
 //launchDetect				// conditional for operating 
 
 unsigned long TimeOfLaunch;
	if (*launchDetect==0){
		do{
			getAcc();
			if (accX>=45){// figure out the acceleration right after launch----------------------------------------------------------
				//why accX? wouldn't we want accY?
				*launchDetect=1;
				TimeOfLaunch=millis();
				launchDetectWrite();
			}
		}
		while(*launchDetect==0);
		return TimeOfLaunch;
	} 
}
		
void Abort(int launchDetect){//tanner
 
	int abortDetect=0;
	getAcc();
	if ((launchDetect==1) && ( (abs(accY)>=32 ) || (abs(accZ)>=32))){
		abortWrite();
		abortDetect=1;
		closeServo();
		do{
			getAcc();
			getAlt();
			delay(200);
			writeData();
			}
		while(abortDetect==1);
	}			
}
	
double SlopeVelocity(unsigned long OldTime, unsigned long time, double alt_prev, double alt_refine){
	double Slope,OldTimeDouble,timeDouble;
	OldTimeDouble=OldTime;
	timeDouble=time;
	Slope=((alt_refine-alt_prev)/((timeDouble/1000)-(OldTimeDouble/1000)));
	return Slope;
}


